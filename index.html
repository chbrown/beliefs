<!DOCTYPE html>
<meta charset="utf-8">
<link rel="icon" href="/static/favicon.ico" type="image/x-icon">
<title>Beliefs</title>
<script>var started = new Date();</script>
<link href="/static/site.css" rel="stylesheet" type="text/css" />
<script src="/static/lib/js/jquery.js"></script>
<script src="/static/lib/js/jquery.persistance.js"></script>
<script src="/static/lib/js/backbone_pkg.js"></script>
<script src="/static/lib/js/d3.v2.js"></script>
<script src="/static/lib/js/date.js"></script>
<script src="/static/local.js"></script>

<div id="container">
  <div id="controls">
    <fieldset><legend>Graph generation</legend>
      <label>N <input id="N" value="50" type="text" data-persist title="Cardinality of population" /></label>
      <label>K <input id="K" value="5" type="text" data-persist title="Mean degree" /></label>
      <label>β <input id="beta" value="0.3" type="text" data-persist title="Randomness of graph" /></label>
    </fieldset>
    <fieldset><legend>Transmission</legend>
      <label>Initially infected <input id="initial" value="1" type="text" data-persist title="Number of individuals initially infected." /></label>
      <label>Infectiousness <input id="infectiousness" value="0.7" type="text" data-persist title="Probability of an individual becoming infected by a single exposure." /></label>
    </fieldset>
    <fieldset><legend>Transmission</legend>
      <label><input id="animate" type="checkbox" data-persist checked /> Animate Interval (ms)</label>
      <input id="interval" value="100" type="text" data-persist />
    </fieldset>
    <label><input id="visualize" type="checkbox" data-persist checked /> Visualize</label>
    <button id="reload">Reload</button>
  </div>
  <div id="content">
    <div id="chart">
    </div>
  </div>
</div>


<script>
// finish with jquery.persistance.js
_.excludes = function() { return !_.contains.apply(_, arguments); }
function constrain(min, x, max) { return Math.max(min, Math.min(max, x)); }
function assert(condition, message) { if (!condition) throw new Error(message); }
Array.prototype.remove = function(item) {
  // allow removing slices or single objects
  var index = this.indexOf(item);
  if (index !== -1)
    return this.removeAt(index);
};
// Array removeAt - By John Resig (MIT Licensed)
Array.prototype.removeAt = function(index) {
  var rest = this.slice(index + 1 || this.length);
  this.length = index < 0 ? this.length + index : index;
  return this.push.apply(this, rest);
};

function pairSort(pair) {
  return (pair[0] < pair[1]) ? pair : [pair[1], pair[0]];
}
function generateWattsStrogatz(N, K, beta) {
  assert(0 <= beta && beta <= 1, '0 ≤ β ≤ 1 violated!');
  // console.log('Generating Watts Strogatz small world graph', [N, K, Math.log(N), 1].join(' >> '), '| β =', beta);
  var nodes = _.range(N);
  var edges = {};

  // create ring lattice
  for (var a = 0; a < N; a++) {
    for (var j = 0; j < (K / 2); j++) {
      var b = (a + j + 1) % N;
      edges[pairSort([a, b])] = 1;
    }
  }

  var rewire = function(edge) {
    // a < b, guaranteed
    var a = edge[0], b = edge[1];
    // remove the a->b link
    delete edges[edge];
    // find a new edge to make, that doesn't already exist
    //   give up after 100 tries
    for (var i = 0, new_b, new_edge; i < 100; i++) {
      new_b = Math.random() * N | 0;
      new_edge = pairSort([a, new_b]);
      if (edges[new_edge] === undefined && a !== new_b) {
        edges[new_edge] = 1;
        break;
      }
    }
  };

  // do rewirings
  for (var a = 0; a < N; a++) {
    for (var j = 0; j < (K / 2); j++) {
      var b = (a + j + 1) % N;
      if (Math.random() < beta) {
        // rewire! i.e. replace b with some other node on the graph that a is not already connected to.
        rewire([a, b]);
      }
    }
  }

  // edges is undirected, and edges[x] = [a, b] will have a < b for all x
  var edges = Object.keys(edges).map(function(edge_string) {
    return edge_string.split(',').map(function(part) {
      return parseInt(part, 10);
    });
  });
  return {nodes: nodes, edges: edges};
}



var Individual = Backbone.Model.extend({
  initialize: function(opts) {
    this.friends = [];
    // inbox is a dictionary whose keys are timesteps, and values are lists of Infections
    this.inbox = {};
    this.outbox = {};
  },
  // addFriend: function(friend) {
  //   if (friend !== this && _.excludes(this.friends, friend)) {
  //     this.friends.push(friend);
  //   }
  // },
  receive: function(timestep, infection) {
    if (this.inbox[timestep] === undefined) this.inbox[timestep] = [];
    if (infection)
      this.inbox[timestep].push(infection);
    // if (_.excludes(this.infections(), infection)) {
    //   // otherwise, contract with probability 1 -
    //   var rand_unif = Math.random();
    //   if (rand_unif < infection.infectiousness) {
    //     this.inbox.push({infection: infection, timestep: timestep});
    //   }
    // }
  },
  outboxAt: function(timestep) {
    if (!this.outbox[timestep]) {
      // inherit the old outbox directly if we have one
      var heeded = (this.outbox[timestep - 1] || []).slice(0);
      this.inbox[timestep].forEach(function(infection) {
        if (Math.random() < infection.infectiousness) {
          heeded.push(infection);
        }
      });
      // remove duplicates (can only have a disease once at a time)
      this.outbox[timestep] = _.uniq(heeded, function(message) {
        return message.name;
      })
    }
    return this.outbox[timestep];
  },
  active: function(timestep) {
    // DON'T (for now): use outbox[ts] instead of outboxAt to ensure that it's already been computed
    return this.outboxAt(timestep).length > 0;
  }
});

var Infection = Backbone.Model.extend({
  initialize: function(opts) {
    this.name = opts.name;
    this.infectiousness = opts.infectiousness;
  }
});

var Population = Backbone.Model.extend({
  initialize: function(opts) {
    // opts.nodes (list of integers) and opts.edges (list of pairs of integers) must be set
    var individuals = this.individuals = opts.nodes.map(function(i) {
      return new Individual({});
    });
    opts.edges.forEach(function(edge) {
      // the edges that generateWattsStrogatz returns are undirected
      individuals[edge[0]].friends.push(individuals[edge[1]]);
      individuals[edge[1]].friends.push(individuals[edge[0]]);
    });
  },
  nodes: function() {
    return this.individuals;
  },
  links: function() {
    var all_links = []; // list of (directed) {source: node1, target: node2} objects
    this.individuals.forEach(function(individual, i) {
      individual.friends.forEach(function(friend) {
        all_links.push({source: individual, target: friend});
      });
    });
    return all_links;
  },
  // toString: function() {
  //   return this.individuals.map(function(individual, i) {
  //     return i + ':' + individual.toString();
  //   }).join(' ');
  // },
  // infected: function(timestep) {
  //   this.individuals.filter(function(individual) {
  // });
  activeIndividuals: function(timestep) {
    return _.filter(this.individuals, function(individual) { return individual.active(timestep); });
  }
});

var Simulation = Backbone.Model.extend({
  timestep: 0,
  r: 4,
  total: false,
  initialize: function(opts) {
    // if opts.visualize is true, expect opts.svg, and opts.population
    this.population = opts.population;
    this.visualize = opts.visualize;
    if (this.visualize) {
      this.initializeViz(opts.svg);
      this.updateViz();
    }
  },
  initializeViz: function(svg) {
    var nodes = this.population.nodes(),
      links = this.population.links();
    // mostly from http://bl.ocks.org/4062045
    this.width = parseInt(svg.attr('width'), 10);
    this.height = parseInt(svg.attr('height'), 10);

    this.force = d3.layout.force()
      .size([this.width, this.height])
      .charge(-1500)
      .linkDistance(90)
      .friction(0.3)
      .nodes(nodes)
      .links(links)
      .start();

    svg.selectAll('g.network').remove();
    var g = svg.append('g')
      .attr('class', 'network');

    this.link = g.selectAll('line.link')
        .data(links)
      .enter().append('line')
        .attr('class', 'link');

    this.node = g.selectAll('circle.node')
        .data(nodes)
      .enter().append('circle')
        .attr('class', 'node')
        .call(this.force.drag);
    // node.append('title')
        // .text(function(d) { return d.name; });

    this.timestep_label = g.append('text')
        .attr('class', 'label')
        .attr('x', 5)
        .attr('y', 15);

    var self = this;
    this.force.on('tick', function() {
      self.updateViz();
    });
  },
  updateViz: function() {
    var self = this;
    this.link
      .attr('x1', function(d) { return d.source.x; })
      .attr('y1', function(d) { return d.source.y; })
      .attr('x2', function(d) { return d.target.x; })
      .attr('y2', function(d) { return d.target.y; })
      .style('stroke-width', function(d) {
        return (d.source.active(self.timestep) * 1.5) + 0.4;
      })
      .style('stroke', function(d) {
        return d.source.active(self.timestep) > 0 ? '#798' : 'orange';
      });

    this.node.attr('cx', function(d) { return d.x = constrain(self.r, d.x, self.width - self.r); })
      .attr('cy', function(d) { return d.y = constrain(self.r, d.y, self.height - self.r); })
      .attr('r', function(d) { return d.active(self.timestep) > 0 ? self.r + .75 : self.r - .75; })
      .style('fill', function(d) { return d.active(self.timestep) > 0 ? '#798' : 'orange'; });

    this.timestep_label.text('t = ' + (self.timestep));
  },
  step: function() {
    var self = this;
    // proceed with the next wave, i.e. send messages around
    this.timestep++;
    // timestamp = 1 is the first one that we send around messages for
    this.population.individuals.forEach(function(individual) {
      individual.friends.forEach(function(friend) {
        // calculate what goes to all the friends' inboxes from this individuals' last outbox
        individual.outboxAt(self.timestep - 1).forEach(function(infection) {
          friend.receive(self.timestep, infection);
        });
      });
      // zero out his inbox
      individual.receive(self.timestep);
    });
    // at this point, all infections for the "timestamp" slot are finished.
    // so we solidify the results, but calling out whose active
    var total_active = this.population.activeIndividuals(this.timestep).length;
    this.total = total_active === this.population.individuals.length;

    if (this.visualize)
      this.updateViz();

    return total_active;
  },
  // his tory: function() {
  //   var self = this;
  //   // count and record current infections
  //   return _.range(this.timestep + 2).map(function(timestep) {
  //     return self.population.individuals.filter(function(individual) {
  //       return individual.infections(timestep).length
  //     }).length;
  //   });
  // }
});

var Generator = Backbone.Model.extend({
  initialize: function(opts) {
    this.records = [];
    this.animateInterval = null;
  },
  reset: function() {
    var N = constrain(2, parseInt($('#N').val(), 10), 100000);
    var K = parseInt($('#K').val(), 10);
    var beta = parseFloat($('#beta').val(), 10);
    assert(!isNaN(N), "N must be a number!");

    // Watts and Strogatz
    var graph = generateWattsStrogatz(N, K, beta);
    // graph.nodes and graph.edges are now set correctly
    var population = new Population(graph);
    window.population = population;

    // start if off. patient zero(s).
    var infectiousness = constrain(0, parseFloat($('#infectiousness').val()), 1.0);
    var flu = new Infection({name: 'flu', infectiousness: infectiousness});
    var initial = constrain(1, parseInt($('#initial').val(), 10), N);
    assert(!isNaN(initial), "Initially infected must be a number!");

    // just zero out the other individuals (sending nothing to the initial group doesn't change anything)
    population.individuals.forEach(function(individual) { individual.receive(0); });
    for (var i = 0; i < initial; i++) {
      var k;
      // give up after 100 tries to avoid infinite loop (e.g., initial = N - 1)
      for (var j = 0; j < 100; j++) {
        k = Math.random() * N | 0;
        if (!population.individuals[k].outbox.length)
          break;
      }
      // console.log("Forcefully implanting/infecting", k, population.individuals[k]);
      population.individuals[k].outbox[0] = [flu];
    }

    var interval_ms = constrain(10, parseInt($('#interval').val(), 10), 5000);

    this.visualize = $('#visualize').prop('checked');
    this.animate = $('#animate').prop('checked');
    var self = this;
    if (this.animate) {
      this.animateInterval = setInterval(function() {
        self.step();
      }, this.visualize ? interval_ms : 10);
    }

    this.simulation = new Simulation({population: population, visualize: this.visualize, svg: svg});
  },
  step: function() {
    if (this.simulation === undefined || this.simulation.total) {
      // console.log("Beginning:", this.simulation === undefined, "/ Simulation-total", (this.simulation || {}).total);
      if (this.animate) {
        clearInterval(this.animateInterval);
      }
      this.reset();
      this.records.push([this.simulation.population.activeIndividuals(0).length]);
    }
    else {
      var infected = this.simulation.step();
      _.last(this.records).push(infected);
      this.renderHistory();
    }
  },
  renderHistory: function() {
    var svg_height = parseInt(svg.attr('height'), 10);
    var svg_width = parseInt(svg.attr('width'), 10);
    var records = this.records;
    var history_width = svg_width - 80, history_height = this.visualize ? 180 : svg_height - 40;
    // body_width = svg_width - (margins.left + margins.right),
    // body_height = svg_height - (margins.top + margins.bottom);
    // window.records = records;

    var x_max = d3.max(records, function(d) { return d.length; }),
      xScale = d3.scale.linear().domain([0, x_max]).range([0, history_width]),
      xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickFormat(d3.format('d')),
      // .tickSize(-body_height).tickPadding(5).ticks(d3.time.days, 1),
      y_max = d3.max(records, function(d) { return d3.max(d); }),
      yScale = d3.scale.linear().domain([0, y_max]).range([history_height, 0]),
      yAxis = d3.svg.axis().scale(yScale).orient('left').tickFormat(d3.format('d'));

    var color = d3.scale.category20();

    svg.selectAll('g.history').remove();
    var g = svg.append('g')
      .attr('class', 'history')
      .attr('width', history_width)
      .attr('height', history_height)
      .attr('transform', 'translate(' + 40 + ',' + (svg_height - history_height - 25) + ')');

    g.append('g')
      .attr('class', 'x axis')
      .attr('transform', 'translate(0,' + history_height + ')')
      .call(xAxis)

    g.append('g')
      .attr('class', 'y axis')
      .call(yAxis)

    g.append('g')
      .attr('class', 'messages')
    .selectAll('path')
      .data(records)
    .enter().append('path')
      // .attr('class', 'history')
      .attr('stroke', function(d, i) { return color(i); })
      .attr('fill', 'none')
      .attr('d', d3.svg.line()
        .x(function(d, i) { return xScale(i); })
        .y(function(d, i) { return yScale(d); })
      );
  }
});

var world_records = [];

var generator = new Generator();
var svg;
$('#reload').click(step);
$('#visualize').on('click', function() {
  // if they check off the visualize checkbox, remove the graph
  if (!$(this).prop('checked')) {
    svg.selectAll('g.network').remove();
  }
})

function step() {
  generator.step();
}
persistence.on('ready', function() {
  $('#chart').height(document.height - $('#controls').outerHeight(true) - 16).empty();
  var width = $('#chart').width(),
    height = $('#chart').height();
  svg = d3.select('#chart').append('svg')
    .attr('width', width)
    .attr('height', height);
  step();
});
$(document).on('keydown', function(ev) {
  // newline: 32, space: 13
  if (ev.which === 32 || ev.which === 13) {
    generator.step();
  }
});

</script>
